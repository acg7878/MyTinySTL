# C++ 模板：全特化 (Full Template Specialization)

**模板全特化 (Full Template Specialization)** 是一种 C++ 模板编程技术，它允许你为一个**特定的类型组合**提供一个完全不同的模板实现。

## 01 概念

在 C++ 中，模板是一种泛型编程工具，它允许你编写可以用于多种类型的代码，而无需为每种类型都编写一份单独的代码。

但是，在某些情况下，泛型代码对于某些特定类型可能不是最优的，甚至无法工作。这时，你就可以使用模板特化来为这些特定类型提供定制化的实现。

模板特化分为两种：
*   **全特化 (Full Specialization)**：为模板的**所有**模板参数都指定具体的类型。
*   **偏特化 (Partial Specialization)**：只为模板的**部分**模板参数指定具体的类型，而让剩余的参数仍然保持泛型。

本文档只关注**全特化**。

## 02 语法

模板全特化的语法如下：

```cpp
template <> // 模板参数列表为空！
struct MyTemplate<SpecificType1, SpecificType2> {
    // ... 针对 SpecificType1 和 SpecificType2 的特殊实现 ...
};
```

关键点：
1.  **`template <>`**: 模板参数列表必须为空，表示这是一个全特化版本，而不是一个泛化的模板。
2.  **`MyTemplate<SpecificType1, SpecificType2>`**: 在模板名称后面的尖括号中，必须指定所有模板参数的具体类型。

### 示例

```cpp
template <typename T, typename U>
struct MyTemplate {
    static void print() { std::cout << "Generic template\n"; }
};

// 全特化版本：当 T 是 int 且 U 是 double 时
template <>
struct MyTemplate<int, double> {
    static void print() { std::cout << "Specialized for int and double\n"; }
};

// 全特化版本：当 T 和 U 都是 bool 时
template <>
struct MyTemplate<bool, bool> {
    static void print() { std::cout << "Specialized for bool and bool\n"; }
};

int main() {
    MyTemplate<float, char>::print();   // 输出 "Generic template"
    MyTemplate<int, double>::print();  // 输出 "Specialized for int and double"
    MyTemplate<bool, bool>::print();    // 输出 "Specialized for bool and bool"
}
```

## 03 应用场景

### a) 性能优化

对于某些类型，泛型代码可能效率较低。通过全特化，我们可以为这些类型提供更高效的实现。

例如，对于 POD 类型，我们可以使用 `memcpy` 来进行快速复制，而不是逐个元素地赋值。

### b) 解决类型不匹配问题

某些类型可能不满足泛型代码的要求，导致编译错误。通过全特化，我们可以为这些类型提供一个能够正常工作的特殊版本。

### c) 代码分支选择

全特化可以用于在编译期根据类型选择不同的代码分支。

## 04 总结

模板全特化是一种强大的 C++ 模板编程技术，它允许我们为特定的类型组合提供定制化的实现，从而实现性能优化、解决类型不匹配问题以及进行代码分支选择。