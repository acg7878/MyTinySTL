# 五/三/零法则

“五/三/零法则” (The Rule of Five/Three/Zero) 是 C++ 中关于如何管理**特殊成员函数 (special member functions)** 的一组核心指导原则。这些函数控制着对象的生命周期，包括创建、拷贝、移动和销毁。正确地管理它们对于避免资源泄漏和保证程序正确性至关重要。

## 01 特殊成员函数

C++ 类中有六个特殊的成员函数，编译器可以在某些情况下为它们自动生成默认版本：
1.  **默认构造函数**: `MyClass();`
2.  **析构函数**: `~MyClass();`
3.  **拷贝构造函数**: `MyClass(const MyClass&);`
4.  **拷贝赋值运算符**: `MyClass& operator=(const MyClass&);`
5.  **移动构造函数** (C++11): `MyClass(MyClass&&);`
6.  **移动赋值运算符** (C++11): `MyClass& operator=(MyClass&&);`

## 02 三法则 (The Rule of Three) - C++98/03

**法则内容**：
> 如果一个类需要显式地声明**析构函数**、**拷贝构造函数**或**拷贝赋值运算符**中的**任何一个**，那么它**几乎肯定需要同时声明这三个**。

**原因**：
需要自定义这三个函数，通常意味着这个类在**直接管理资源**（如裸指针、文件句柄、网络套接字等）。
-   **析构函数**：用于释放资源。
-   **拷贝构造函数**和**拷贝赋值运算符**：必须被定义以实现**深拷贝 (deep copy)**。如果使用编译器生成的默认版本，它们只会执行**浅拷贝 (shallow copy)**，导致多个对象指向同一份资源，最终引发**二次释放 (double free)** 等严重错误。

**示例**：
```cpp
class ResourceManager {
private:
    int* data;
public:
    // 1. 自定义析构函数来释放资源
    ~ResourceManager() { delete[] data; }

    // 2. 自定义拷贝构造函数来实现深拷贝
    ResourceManager(const ResourceManager& other) {
        data = new int[10];
        std::copy(other.data, other.data + 10, data);
    }

    // 3. 自定义拷贝赋值运算符来实现深拷贝
    ResourceManager& operator=(const ResourceManager& other) {
        if (this != &other) {
            delete[] data;
            data = new int[10];
            std::copy(other.data, other.data + 10, data);
        }
        return *this;
    }
};
```

## 03 五法则 (The Rule of Five) - C++11

**法则内容**：
> 如果一个类遵循三法则，那么它**几乎肯定还需要**定义**移动构造函数**和**移动赋值运算符**。

**原因**：
C++11 引入了**移动语义 (move semantics)**，这是一种高效的资源所有权转移机制。如果一个类管理着资源，那么它应该同时支持**拷贝**（代价高昂）和**移动**（高效）。
-   **移动构造函数**和**移动赋值运算符**：通过“窃取”源对象的资源指针并将其置空，来避免不必要的深拷贝。

如果只实现了三法则而没有实现移动操作，那么当遇到需要移动的场景时（例如，从函数返回一个对象），程序会回退到使用拷贝操作，从而损失了性能。

## 04 零法则 (The Rule of Zero)

**法则内容**：
> **优先编写不需要自定义析构函数、拷贝/移动构造和拷贝/移动赋值的类。**

**原因**：
这是现代 C++ 最推荐的做法。它鼓励你使用 **RAII (Resource Acquisition Is Initialization)** 原则，将资源管理委托给专门的**资源管理类**。
-   **智能指针**：使用 `std::unique_ptr` 或 `std::shared_ptr` 来管理动态分配的内存。
-   **标准库容器**：使用 `std::vector`, `std::string` 等来管理动态数组和字符串。

这些资源管理类本身已经完美地实现了五法则。当你的类将资源管理委托给它们时，编译器为你自动生成的默认特殊成员函数将会正确地调用这些成员的对应函数，从而自动实现正确的拷贝、移动和销毁行为。

**示例**：
```cpp
class ResourceManager {
private:
    // 使用 std::vector 和 std::unique_ptr 管理资源
    std::vector<int> data;
    std::unique_ptr<OtherResource> resource;
public:
    // 不需要写任何特殊成员函数！
    // 编译器生成的版本会自动调用成员的对应函数，行为完全正确。
};
```
遵循零法则可以让你的代码更简洁、更安全、更易于维护。只有在编写底层的数据结构或资源管理器时，才需要考虑五法则。