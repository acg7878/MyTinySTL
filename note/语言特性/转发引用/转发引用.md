# 转发引用 (Forwarding References)

**转发引用 (Forwarding References)**，也被称为 **万能引用 (Universal References)**，是 C++11 引入的一种特殊的引用类型。它在语法上与右值引用 `T&&` 完全相同，但其行为却大相径庭。

## 01 区分右值引用和转发引用

关键在于，`T&&` 只有在满足以下**两个条件**时，才会被视为转发引用：

1.  它必须具有 `T&&` 的形式。
2.  类型推导必须参与其中。

当这两个条件满足时，`T&&` 就会变成一个“万能”的引用，它可以根据传入的参数类型，自动“折叠”成左值引用或右值引用。

### 示例

```cpp
template <typename T>
void func(T&& arg) { // arg 是一个 forwarding reference
    // ...
}

int x = 10;
func(x);         // T 被推导为 int&，arg 的类型是 int& &&，折叠为 int&
func(20);        // T 被推导为 int，arg 的类型是 int&& (右值引用)

template <typename T>
class MyClass {
public:
    template <typename U>
    void method(U&& arg) { // arg 是一个 forwarding reference
        // ...
    }
};
```

在这些例子中，`arg` 都是转发引用，因为它们都满足了 `T&&` 的形式，并且 `T` 或 `U` 都是需要通过函数调用进行推导的模板参数。

但是，以下情况**不是**转发引用：

```cpp
template <typename T>
void func(std::vector<T>&& arg) { // arg 不是 forwarding reference
    // ...
}

template <typename T>
class MyClass {
public:
    void method(T&& arg) { // arg 不是 forwarding reference
        // ...
    }
};
```

在这些例子中，`arg` 只是一个普通的右值引用，因为 `T` 已经被 `MyClass` 或 `func` 模板参数列表确定了，不需要再进行推导。

## 02 引用折叠 (Reference Collapsing)

转发引用的核心机制是**引用折叠 (reference collapsing)**。

引用折叠规则定义了当一个引用类型“嵌套”在另一个引用类型中时，最终会得到什么类型。

具体来说，有以下四种情况：

1.  `A& &` 折叠为 `A&` (左值引用的引用仍然是左值引用)
2.  `A& &&` 折叠为 `A&` (左值引用的右值引用仍然是左值引用)
3.  `A&& &` 折叠为 `A&` (右值引用的左值引用仍然是左值引用)
4.  `A&& &&` 折叠为 `A&&` (右值引用的右值引用是右值引用)

**记忆技巧**：只要有**任何一个是左值引用**，结果就是左值引用。只有**全是右值引用**，结果才是右值引用。

## 03 完美转发 (Perfect Forwarding)

转发引用通常与 `std::forward` 结合使用，以实现**完美转发 (perfect forwarding)**。

完美转发是指将函数参数以其原始的值类别（左值或右值）传递给另一个函数。

`std::forward<T>(arg)` 就可以根据 `T` 的类型，将 `arg` 转换为左值或右值。

## 04 总结

转发引用是一种特殊的引用类型，它在模板编程中用于接受任意类型的参数，并保留其原始的值类别。它与引用折叠和 `std::forward` 结合使用，可以实现完美转发，从而编写出更通用、更高效的代码。