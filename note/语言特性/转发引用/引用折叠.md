# 引用折叠 (Reference Collapsing)

**引用折叠 (Reference Collapsing)** 是 C++11 引入的一项规则，它定义了在特定情况下，多个引用类型如何“折叠”成一个单独的引用类型。这项规则主要用于**模板类型推导 (template type deduction)** 和 **`auto` 类型推导**中，特别是与**万能引用 (universal references)** 结合使用时。

## 01 引用类型

在 C++ 中，我们有以下几种引用类型：

1.  **左值引用 (lvalue reference)**: `T&`
    *   可以绑定到左值（具有名称和地址的对象）。
    *   例如：`int x = 10; int& ref = x;`

2.  **右值引用 (rvalue reference)**: `T&&`
    *   可以绑定到右值（临时对象、字面量等）。
    *   例如：`int&& ref = 10;`

## 02 引用折叠规则

引用折叠规则定义了当一个引用类型“嵌套”在另一个引用类型中时，最终会得到什么类型。

具体来说，有以下四种情况：

1.  `A& &` 折叠为 `A&` (左值引用的引用仍然是左值引用)
2.  `A& &&` 折叠为 `A&` (左值引用的右值引用仍然是左值引用)
3.  `A&& &` 折叠为 `A&` (右值引用的左值引用仍然是左值引用)
4.  `A&& &&` 折叠为 `A&&` (右值引用的右值引用是右值引用)

可以用一个表格来总结：

| 原始类型 | 折叠后的类型 |
| :------- | :----------- |
| `A& &`   | `A&`         |
| `A& &&`  | `A&`         |
| `A&& &`  | `A&`         |
| `A&& &&` | `A&&`        |

**记忆技巧**：只要有**任何一个是左值引用**，结果就是左值引用。只有**全是右值引用**，结果才是右值引用。

## 03 万能引用 (Universal References)

引用折叠真正发挥威力的地方是在**万能引用 (universal reference)** 中。

万能引用是一种特殊的引用类型，它看起来像右值引用 `T&&`，但只有在满足以下两个条件时，它才会被解释为万能引用：

1.  它必须具有 `T&&` 的形式。
2.  `T` 必须是一个需要被推导的类型参数。

当这两个条件满足时，`T&&` 就会根据传入的参数类型，发生引用折叠，从而变成左值引用或右值引用。

```cpp
template <typename T>
void func(T&& arg) { // arg 是一个万能引用
    // ...
}

int x = 10;
func(x);         // T 被推导为 int&，arg 的类型是 int& &&，折叠为 int& (左值引用)
func(20);        // T 被推导为 int，arg 的类型是 int&& (右值引用)
```

## 04 完美转发 (Perfect Forwarding)

万能引用是实现**完美转发 (perfect forwarding)** 的基础。完美转发是指将函数参数以其原始的值类别（左值或右值）传递给另一个函数。

`std::forward<T>(arg)` 就可以根据 `T` 的类型，将 `arg` 转换为左值或右值。